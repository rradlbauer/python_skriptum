# 27.0 Container und Iterable

Als Container bezeichnen wir Objekte, welche andere Objekte verwalten.
Du kennst inzwischen schon einige Container, 
wie z.B. `list`, `set` und `dict`.
Container sind eine wichtige Kategorie von Objekten in allen Programmiersprachen.
Daher soll dieses Kapitel einen Überblick über Container geben
und deren wichtigste Eigenschaften erläutern.

Hier werden die Eigenschaften anhand der Programmiersprache Python
erklärt. Die Konzepte finden sich aber in fast allen 
modernen Programmiersprachen wieder.

## Eigenschaften von Containern

Hier ist eine Aufzählung der wichtigsten Eigenschaften von Containern:
- **Zugriff auf Elemente**: Container ermöglichen den Zugriff auf ihre Elemente, 
  z.B. über einen Index (wie bei `list`) oder über einen Schlüssel
    (wie bei `dict`).
- **Hinzufügen und Entfernen von Elementen**: 
  Container erlauben das Hinzufügen 
  und Entfernen von Elementen.
- **Iteration**: Container können durchlaufen werden, 
  um auf alle ihre Elemente zuzugreifen.
- **Länge**: Container haben eine definierte Länge, 
  die angibt, wie viele Elemente sie enthalten.
- **Containment-Prüfung**: Container ermöglichen die Überprüfung, 
  ob ein bestimmtes Element enthalten ist.

### Zugriff auf Elemente

Viele Container erlauben den Zugriff auf bestimmte Elemente:
- Auf einzelne Elemente einer Liste (`list`) 
  oder eines Tupels (`tuple`) kann über den Index zugegriffen werden.
- Bei Dictionaries (`dict`) erfolgt der Zugriff über Schlüssel.

Es gibt aber auch Container,
die keinen direkten Zugriff auf einzelne Elemente erlauben,
wie z.B. ein Set (`set`).

### Iteration

Unter Iteration versteht man, dass nacheinander 
Elemente eines Containers durchlaufen werden.
Mit jedem Element wird dann eine bestimmte Aktion ausgeführt,
z.B. das Ausgeben des Elements, 
das Durchführen einer Berechnung mit dem Element, etc.

Wie du über die Elemente eines Containers iterierst,
weißt du bereits - mit einer `for`-Schleife:

```python
# Beispiel für eine Liste
meine_liste = [1, 2, 3, 4, 5]
for element in meine_liste:
    print(element)  # Ausgabe: 1, 2, 3, 4, 5
```

Iterieren kann man über alles was "iterierbar" ist.
In Python kann man Instanzen einer Klasse iterierbar machen,
indem man die spezielle Methode `__iter__` implementiert:

```python
class MeineKlasse:
    def __init__(self, werte):
        self.werte = werte

    def __iter__(self):
        for wert in self.werte:
            yield wert  # gibt nacheinander die Werte zurück   
                

# Beispiel für die Verwendung
meine_instanz = MeineKlasse([1, 2, 3])
for wert in meine_instanz:
    print(wert)  # Ausgabe: 1, 2, 3
```





















### Objekt-Instanzen verhalten sich wie Container

Um zu erreichen, dass sich Objekt-Instanzen wie Container verhalten,
gibt es ebenfalls verschiedene spezielle Methoden.
Diese werden aber in einem späteren Kapitel genauer behandelt.


### Verhalten von Containern

In Python gibt es viele eingebaute 
Container-Typen wie Listen, Dictionaries und Sets.
Wir können das Verhalten der Klasse `Vektor`
mit speziellen Methoden so anpassen, 
dass sie sich wie ein Container verhält.

```python
# die Methoden für das Rechnen wurden hier ausgelassen (siehe oben)
class Vektor:
    # Konstruktor: wird automatisch aufgerufen, wenn eine Instanz der Klasse erstellt wird
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

    # wird aufgerufen, wenn ein Element per Index abgerufen wird
    def __getitem__(self, index):
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        elif index == 2:
            return self.z
        else:
            raise IndexError("Index außerhalb des Bereichs")

    # wird aufgerufen, wenn ein Element per Index gesetzt wird
    def __setitem__(self, index, value):
        if index == 0:
            self.x = value
        elif index == 1:
            self.y = value
        elif index == 2:
            self.z = value
        else:
            raise IndexError("Index außerhalb des Bereichs")

    # wird aufgerufen, wenn die Länge des Objekts abgefragt wird
    def __len__(self):
        return 3  # Dieser Vektor hat immer zwei Komponenten

    # wird aufgerufen, wenn das Objekt als String dargestellt wird
    def __str__(self):
        return f"Vektor({self.x}, {self.y}, {self.z})"

    # wird aufgerufen, wenn das Objekt iteriert wird (z.B. in einer Schleife)
    def __iter__(self): # diese Methode wird in einem späteren Kapitel noch genauer behandelt
        yield self.x
        yield self.y
        yield self.z

    # wird aufgerufen, um zu überprüfen, ob ein Wert im Objekt enthalten ist (z.B. mit 'in' Operator)
    def __contains__(self, value):
        return value in (self.x, self.y)

    # wird aufgerufen, wenn das Objekt als Funktion aufgerufen wird
    def __call__(self):
        return f"Vektor({self.x}, {self.y})"

# Beispiel für die Verwendung
v = Vektor(3, 4, 5)
print(v[0])  # Ausgabe: 3
print(v[1])  # Ausgabe: 4
print(v[2])  # Ausgabe: 5
v[0] = 5 # Vektor hat nun die Komponenten 5, 4, 5
print(v)      # Ausgabe: Vektor(5, 4, 5)
print(len(v))  # Ausgabe: 3
for komponente in v:
    print(komponente)  # Ausgabe: 5, 4, 5
print(4 in v)  # Ausgabe: True
print(v())  # Aufruf als Funktion - Ausgabe: Vektor(5, 4)
```

Die Methode `__delitem__` kann ebenfalls implementiert werden,
um das Löschen von Elementen zu ermöglichen,
aber in diesem Beispiel haben wir sie weggelassen,
da sie für Vektoren nicht unbedingt sinnvoll ist.


[<<](28.0_spezielle_Methoden.md) &emsp; [>>](#)