# 26.0 Spezielle Methoden

In Python-Klassen können spezielle Methoden definiert werden, 
die das Verhalten von Instanzen der jeweiligen Klasse beeinflussen. 
Diese Methoden haben spezielle Namen und werden automatisch aufgerufen, 
wenn bestimmte Operationen auf Instanzen der Klasse angewendet werden.
Sie werden auch "Magic Methods" oder "Dunder Methods"
(double underscore) genannt,
da sie in der Regel mit zwei Unterstrichen beginnen und enden 
(z.B. `__init__`, `__str__`).

Die Methode `__init__` kennst du bereits.
Wir nennen sie auch "Konstruktor",
da sie aufgerufen wird,
wenn eine neue Instanz der Klasse erstellt wird.

Hier werden einige weitere wichtige spezielle Methoden vorgestellt.

### Objekt-Instanzen verhalten sich wie Strings

Es gibt viele Situationen, in denen eine Instanz einer Klasse 
als String dargestellt werden soll, 
z.B. wenn die Instanz in der Konsole ausgegeben wird.
In Python kannst du das Verhalten der String-Darstellung
einer Instanz durch die Definition der speziellen Methode 
`__str__` anpassen.

```python
class Person:
    def __init__(self, name : str, alter : int):
        self.name : str = name
        self.alter : int = alter

    def __str__(self) -> str:
        return f"{self.name}, {self.alter} Jahre alt"
        
person = Person("Max", 30)
print(person)          # Ausgabe: Max, 30 Jahre alt
```

Bemerkung: Es gibt auch die spezielle Methode `__repr__`,
die eine formale String-Darstellung der Instanz zurückgibt,
die für Debugging-Zwecke nützlich ist.

### Objekt-Instanzen verhalten sich wie Zahlen

Normalerweise kann man mit Objekt-Instanzen nicht rechnen.
Es ergibt z.B. keinen Sinn, zwei Instanzen einer Klasse `Person`
zu addieren oder zu subtrahieren.

Anders verhält es sich z.B. bei Zeitpunkten (Instanzen der Klasse `datetime`).
Im Abschnitt [13.0 Datum und Uhrzeit](../skriptum/13.0_Datum_und_Uhrzeit.md)
hast du gelernt, dass du zwei 
`datetime`-Instanzen subtrahieren kannst.
Das liegt daran, dass die Klasse `datetime`
die spezielle Methode `__sub__` implementiert hat.
Sie ist so definiert, dass sie die Differenz zwischen 
zwei `datetime`-Instanzen berechnet und diese Differenz als 
`timedelta`-Instanz zurückgibt.

Ähnlich kann man definieren, dass Instanzen einer eigenen Klasse
mit den mathematischen Operatoren `+`, `-`, `*` und `/`
addiert, multipliziert, subtrahiert oder dividiert werden können.

```python
class Vektor:
    def __init__(self, x : float, y : float):
        self.x : float = x
        self.y : float = y

    def __add__(self, other : 'Vektor') -> 'Vektor':
        return Vektor(self.x + other.x, self.y + other.y)

    def __sub__(self, other : 'Vektor') -> 'Vektor':
        return Vektor(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar : float) -> 'Vektor':
        return Vektor(self.x * scalar, self.y * scalar)

    def __truediv__(self, scalar : float) -> 'Vektor':
        return Vektor(self.x / scalar, self.y / scalar)

    def __str__(self) -> str:
        return f"Punkt({self.x}, {self.y})"
    
    
punkt1 = Vektor(2, 3)
punkt2 = Vektor(4, 5)
punkt3 = punkt1 + punkt2
print(punkt3)  # Ausgabe: Punkt(6, 8)
punkt4 = punkt1 - punkt2
print(punkt4)  # Ausgabe: Punkt(-2, -2)
punkt5 = punkt1 * 2
print(punkt5)  # Ausgabe: Punkt(4, 6)
punkt6 = punkt1 / 2
print(punkt6)  # Ausgabe: Punkt(1.0, 1.5)
```

In dieser Klasse `Vektor` haben wir die speziellen Methoden
`__add__`, `__sub__`, `__mul__` und `__truediv__` definiert,
um die Addition, Subtraktion, 
Multiplikation und Division von Vektoren zu ermöglichen.

Interessant ist hier, dass die Division mit
`__truediv__` definiert ist. Es gibt auch noch die 
speziellen Methoden `__floordiv__` und `__mod__`.
Vielleicht kannst du erraten, was sie tun.

### Objekt-Instanzen vergleichen

Wenn du die Klasse `Vektor` von oben verwendest und folgenden
Code ausführst, wirst du vielleicht vom Ergebnis überrascht sein:

```python
punkt1 = Vektor(2, 3)
punkt2 = Vektor(2, 3)
print(punkt1 == punkt2)  # Ausgabe: False
```

Das liegt daran, dass Python die Gleichheit von Objekten standardmäßig
überprüft, indem es die Identität der Objekte vergleicht,
also ob es sich um dasselbe Objekt im Speicher handelt,
welches von den beiden Variablen `punkt1` und `punkt2` referenziert wird.
(siehe  Abschnitt [24.0 Referenzen](../skriptum/24.0_Referenzen.md)).
Hier sind `punkt1` und `punkt2` aber zwei verschiedene Objekte,
die zufällig die gleichen Werte für `x` und `y` haben.

Es wäre aber sinnvoll, wenn zwei Vektoren als gleich betrachtet werden,
wenn sie die gleichen Komponenten haben, also wenn `x` und `y` gleich sind.
Um das zu erreichen, können wir die spezielle Methode `__eq__`
definieren, die aufgerufen wird, wenn der `==`-Operator verwendet wird.

```python
class Vektor:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Vektor):
            return self.x == other.x and self.y == other.y
        return False  
    # die anderen Methoden wurden hier weggelassen (siehe oben)
    
punkt1 = Vektor(2, 3)
punkt2 = Vektor(2, 3)
print(punkt1 == punkt2)  # Ausgabe: True
``` 

Analog können wir auch die Methoden 
`__ne__`, `__lt__`, `__le__`, `__gt__` und `__ge__`
definieren, um Ungleichheit und Größenvergleiche zu ermöglichen.

```python
class Vektor:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def laenge(self):   # Länge des Vektors nach Pythagoras berechnen
        return (self.x**2 + self.y**2) ** 0.5

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        return self.laenge() < other.laenge()

    def __le__(self, other):
        return self.laenge() <= other.laenge()

    def __gt__(self, other):
        return self.laenge() > other.laenge()

    def __ge__(self, other):
        return self.laenge() >= other.laenge()
    # die anderen Methoden wurden hier weggelassen (siehe oben) 
    
    
punkt1 = Vektor(2, 3)
punkt2 = Vektor(3, 4)
print(punkt1 < punkt2)  # Ausgabe: True
print(punkt1 <= punkt2)  # Ausgabe: True
print(punkt1 > punkt2)  # Ausgabe: False
print(punkt1 >= punkt2)  # Ausgabe: False
print(punkt1 == punkt2)  # Ausgabe: False
print(punkt1 != punkt2)  # Ausgabe: True
```

### Weitere spezielle Methoden

Es gibt noch viele weitere spezielle Methoden.
Eine umfassende Liste findest du in der 
[Python-Dokumentation](https://docs.python.org/3/reference/datamodel.html#special-method-names).





## Übungen
[Hier geht's zu den Übungen](../uebungen/UE_28.0_spezielle_Methoden.md)

## Zusammenfassung
### Wichtige Begriffe


### Das sollst du können



[<<](27.0_Datenkapselung.md) &emsp; [>>](29.0_Container.md)