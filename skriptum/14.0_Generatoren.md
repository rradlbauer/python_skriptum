# 9.3 Generatoren in Python

Neben den bereits bekannten Schleifen wie `for` und `while` bietet Python eine weitere mächtige Möglichkeit, um Iterationen zu realisieren: **Generatoren**. Generatoren sind spezielle Funktionen, die es ermöglichen, eine Folge von Werten zu erzeugen, ohne dass alle Werte gleichzeitig im Speicher gehalten werden müssen. Dies ist besonders nützlich, wenn man mit großen Datenmengen arbeitet oder wenn die Werte erst bei Bedarf berechnet werden sollen.

#### Syntax von Generatoren

Die Syntax eines Generators ähnelt der einer normalen Funktion, jedoch wird anstelle von `return` das Schlüsselwort `yield` verwendet. Dieses `yield` pausiert die Funktion und speichert ihren Zustand, sodass sie bei der nächsten Anforderung an derselben Stelle fortgesetzt werden kann.

```python
def generator_funktion():
    yield wert1
    yield wert2
    yield wert3
```

#### Beispiel: Einfacher Generator

Hier ist ein einfaches Beispiel für einen Generator, der die Zahlen von 0 bis `n-1` erzeugt:

```python
def firstn(n):
    num = 0
    while num < n:
        yield num
        num += 1

# Verwendung des Generators
for zahl in firstn(5):
    print(zahl)
```

In diesem Beispiel wird der Generator `firstn` verwendet, um die Zahlen von 0 bis 4 auszugeben. Der Generator erzeugt die Zahlen einzeln und gibt sie bei jedem Schleifendurchlauf zurück, ohne alle Zahlen gleichzeitig im Speicher zu halten.

#### Generator Expressions

Python bietet auch eine Kurzschreibweise für Generatoren, die sogenannten **Generator Expressions**. Diese ähneln den List Comprehensions, verwenden jedoch runde Klammern statt eckiger Klammern.

```python
# List Comprehension
quadrate_liste = [x * x for x in range(10)]

# Generator Expression
quadrate_generator = (x * x for x in range(10))

# Verwendung des Generators
for quadrat in quadrate_generator:
    print(quadrat)
```

Der Unterschied zwischen einer List Comprehension und einer Generator Expression besteht darin, dass die List Comprehension sofort eine vollständige Liste im Speicher erzeugt, während die Generator Expression die Werte erst bei Bedarf erzeugt.

#### Vorteile von Generatoren

1. **Speichereffizienz**: Generatoren erzeugen Werte nur bei Bedarf und halten nicht alle Werte gleichzeitig im Speicher. Dies ist besonders nützlich bei großen Datenmengen.
   
2. **Lazy Evaluation**: Werte werden erst dann berechnet, wenn sie tatsächlich benötigt werden. Dies kann die Performance verbessern, insbesondere wenn nicht alle Werte tatsächlich verwendet werden.

3. **Einfache Implementierung von Iteratoren**: Generatoren bieten eine einfache Möglichkeit, eigene Iteratoren zu implementieren, ohne dass man eine separate Klasse mit `__iter__` und `__next__` Methoden schreiben muss.

#### Beispiel: Zusammensetzung von Generatoren

Generatoren können auch miteinander kombiniert werden, um komplexere Datenströme zu erzeugen. Hier ist ein Beispiel, das die Quadrate der Zahlen erzeugt und nur die Quadrate zurückgibt, die kleiner als 100 sind:

```python
def quadrate():
    for i in range(100):
        yield i * i

def begrenzte_quadrate(generator, grenze):
    for wert in generator:
        if wert < grenze:
            yield wert

# Verwendung der zusammengesetzten Generatoren
for quadrat in begrenzte_quadrate(quadrate(), 100):
    print(quadrat)
```

In diesem Beispiel wird der Generator `quadrate` verwendet, um die Quadrate der Zahlen zu erzeugen, und der Generator `begrenzte_quadrate` filtert nur die Quadrate heraus, die kleiner als 100 sind.
